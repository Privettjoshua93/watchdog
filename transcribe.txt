C:/Code/Watchdog/watchdog/main.py
import os
import time
from threading import Thread
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import tkinter as tk
from tkinter import filedialog, ttk


class RepoMonitor(FileSystemEventHandler):
    def __init__(self, gui):
        self.gui = gui

    def on_any_event(self, event):
        # Schedule a refresh only for relevant events
        if not event.src_path.endswith('transcribe.txt'):
            self.gui.schedule_refresh()


class GUI(tk.Tk):
    BINARY_EXTENSIONS = {'.exe', '.dll', '.so', '.bin', '.jpg', '.jpeg', '.png',
                         '.gif', '.mp3', '.mp4', '.avi', '.mov', '.pdf', '.zip',
                         '.tar', '.gz', '.7z', '.pyc'}

    def __init__(self):
        super().__init__()
        self.title("Repo Monitor")
        self.geometry("600x600")
        self.path = filedialog.askdirectory(title="Select the repository to monitor")
        self.listboxes = {}
        self.labels = {}
        self.refresh_scheduled = False

        self.create_widgets()
        self.refresh_files()  # Populate initial file list

    def create_widgets(self):
        self.frame = tk.Frame(self)
        self.frame.pack(fill=tk.BOTH, expand=True)

        self.canvas = tk.Canvas(self.frame)
        self.scrollbar = ttk.Scrollbar(self.frame, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = ttk.Frame(self.canvas)

        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        )

        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=self.scrollbar.set)

        self.canvas.pack(side="left", fill="both", expand=True)
        self.scrollbar.pack(side="right", fill="y")

        self.loading_label = tk.Label(self, text="", fg="green")
        self.loading_label.pack(side="bottom")

    def is_visible(self, path):
        return not os.path.basename(path).startswith('.')

    def is_binary_file(self, filename):
        return os.path.splitext(filename)[1].lower() in self.BINARY_EXTENSIONS

    def refresh_files(self):
        current_directories = {}

        for root, dirs, files in os.walk(self.path):
            # Exclude hidden directories and files
            dirs[:] = [d for d in dirs if self.is_visible(d)]
            relevant_files = [
                f for f in files if self.is_visible(f) and f != 'transcribe.txt' and not self.is_binary_file(f)
            ]
            if relevant_files:
                rel_dir = os.path.relpath(root, self.path)
                current_directories[rel_dir] = relevant_files

        # Add or update listboxes for current directories
        for directory, file_list in current_directories.items():
            if directory not in self.listboxes:
                label = tk.Label(self.scrollable_frame, text=directory)
                label.pack(anchor='w')
                listbox = tk.Listbox(self.scrollable_frame, selectmode=tk.MULTIPLE, exportselection=0)
                listbox_height = min(len(file_list), 10)
                listbox.config(height=listbox_height)
                listbox.pack(fill=tk.X)
                listbox.bind('<<ListboxSelect>>', lambda e: self.write_to_file())

                for file in file_list:
                    listbox.insert(tk.END, file)

                self.listboxes[directory] = listbox
                self.labels[directory] = label
            else:
                # Update existing listboxes
                listbox = self.listboxes[directory]
                listbox.delete(0, tk.END)
                for file in file_list:
                    listbox.insert(tk.END, file)

        # Remove listboxes and associated labels for directories that no longer exist
        existing_directories = set(self.listboxes.keys())
        for directory in existing_directories - set(current_directories.keys()):
            self.listboxes[directory].destroy()
            del self.listboxes[directory]
            self.labels[directory].destroy()
            del self.labels[directory]

        # Write the current selected files to transcribe.txt
        self.write_to_file()

    def schedule_refresh(self):
        if not self.refresh_scheduled:
            self.refresh_scheduled = True
            self.after(1000, self.refresh_files)

    def write_to_file(self):
        self.loading_label.config(text="Processing...")
        output_path = os.path.join(self.path, 'transcribe.txt')

        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                for directory, listbox in self.listboxes.items():
                    selected_indices = listbox.curselection()
                    for index in selected_indices:
                        selected_file = listbox.get(index)
                        full_path = os.path.abspath(os.path.join(self.path, directory, selected_file))
                        corrected_path = full_path.replace("\\", "/")
                        f.write(f"{corrected_path}\n")
                        try:
                            with open(full_path, 'r', encoding='utf-8') as content_file:
                                f.write(content_file.read() + "\n\n")
                        except (FileNotFoundError, UnicodeDecodeError) as e:
                            print(f"Error processing {full_path}: {e}")
        except Exception as e:
            print(f"Write error: {e}")

        self.loading_label.config(text="")
        self.refresh_scheduled = False


def monitor_directory(gui):
    event_handler = RepoMonitor(gui)
    observer = Observer()
    observer.schedule(event_handler, gui.path, recursive=True)  # Ensure recursive watching
    observer.start()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()


if __name__ == "__main__":
    gui = GUI()

    thread = Thread(target=monitor_directory, args=(gui,))
    thread.daemon = True
    thread.start()

    gui.mainloop()

C:/Code/Watchdog/watchdog/README.md
# watchdog
Monitors your repo, continuously updating a single text file with the file paths and file content of your choosing. This is so you can quickly generate a txt file that can be sent to an LLM for coding assistance on your project.

Clone the repo and run the executable file in the dist folder to launch the script.

# Reqs
in case you want to manually run the main.py file and install the pre-reqs yourself:
pip install watchdog



